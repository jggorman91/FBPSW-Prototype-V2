<script type="module">
        // --- Data from PDF for ABC dropdowns (from previous request) ---
        const bipData = {
            "Physical Aggression": {
                antecedents: ["Task or work demand (difficult or nonpreferred task)", "Being told \"no\" or denied a request", "Transition events (e.g. end of a preferred activity, start of a non-preferred activity)", "Negative peer interactions (teasing, play fights)", "Sensory or environmental triggers (e.g. loud noise, bright lights)", "Long waits or unclear routines"],
                behaviors: ["Biting, hitting, kicking or punching peers or staff", "Throwing, smashing or hurling objects at others or on the floor", "Pushing, shoving, or charging at classmates", "Spitting at others"],
                consequences: ["Adult intervention (e.g. removal to time-out, staff physically stopping the behavior)", "Removal of task or allowance of a break (escape of demand)", "Verbal reprimand or redirection by teacher", "Loss of privileges (e.g. no recess, loss of special activities)", "Peers move away (social escape)"]
            },
            "Verbal Aggression": {
                antecedents: ["Being told \"no,\" corrected or reprimanded", "Frustration with tasks or requests", "Peer provocation or conflict", "Sudden changes or transitions"],
                behaviors: ["Shouting, screaming, or yelling at others", "Name-calling, insults, or profanity directed at peers or adults", "Verbal threats or defiant statements", "Saying \"no\" or arguing with an adult about an instruction"],
                consequences: ["Teacher redirection or verbal reprimand (attention given)", "Student sent to time-out or isolated", "Loss of privileges (e.g. removal from group)", "Peers react (laughter or avoidance)"]
            },
            "Self-Injurious Behavior": {
                antecedents: ["High task demands or frustration (escape)", "Sensory overload or discomfort (e.g. noisy, crowded environment)", "Emotional distress (anxiety, fatigue)", "Physical discomfort (hunger, pain)"],
                behaviors: ["Head hitting or banging against desk, wall, or floor", "Hand or arm biting", "Slapping or scratching one's own body or face", "Hair pulling", "Rocking, hand-flapping, or other repetitive motions (self-stimulatory)"],
                consequences: ["Teacher or aide physically blocks or holds the student to ensure safety", "Task may be removed or student given a break", "Staff provide comfort or attention", "Possible time-out or medical check"]
            },
            "Task Refusal / Noncompliance": {
                antecedents: ["Presentation of a non-preferred or difficult academic demand", "Transition to a non-preferred task", "Being told \"no\" (denied permission)", "Large or lengthy assignments", "Unclear instructions"],
                behaviors: ["Verbal refusal (saying \"no,\" arguing)", "Ignoring the instruction (looking away, covering ears)", "Physically leaving the area or pushing materials away", "Crying, screaming, or tantruming to protest"],
                consequences: ["Task is removed or postponed (student escapes demand)", "Student given a break or allowed preferred activity", "Teacher re-delivers the task or uses prompts", "If tantrum occurs, adult attention may inadvertently reinforce escape"]
            },
            "Elopement (Running Away)": {
                antecedents: ["Being in a non-preferred or overstimulating setting", "Transitions (e.g. before entering a disliked class)", "Unstructured times (e.g. free play, waiting)"],
                behaviors: ["Leaving a supervised area without permission (running out of classroom, playground, hallway or school grounds)", "Climbing fences or running through doors", "Moving rapidly toward an appealing location (e.g. exit, office) or away from demands"],
                consequences: ["Staff chase or physically redirect the student (safety hold)", "Student returned to supervised area (often with close monitoring)", "Removal of privileges or additional supervision", "Student may accidentally be reinforced if elopement leads to escape of the disliked situation"]
            },
            "Disruptive Behavior (Non-Aggressive)": {
                antecedents: ["Boring or highly demanding tasks (student seeks stimulation)", "Long instructional periods without breaks", "Lack of engagement with work", "Unsupervised or unstructured periods", "Need for attention"],
                behaviors: ["Talking out of turn or calling out answers", "Making noises (tapping desk, jingling items, humming)", "Frequent whining or complaining", "Out-of-seat behavior (wandering classroom, showing items)", "Mild defiance (refusing minor requests, interrupting peers)"],
                consequences: ["Teacher attention through redirection or scolding (gaining attention)", "Loss of privileges or rewards", "Brief time-out", "Classmates may laugh or react (peer attention)", "If ignored, student may successfully delay task (escape reinforcement)"]
            },
            "Off-Task Behavior": {
                antecedents: ["Academic work that is too difficult (frustration) or too easy/uninteresting (boredom)", "Lack of clear instructions", "Slow-paced or repetitive tasks", "Insufficient structure or environmental distractions"],
                behaviors: ["Daydreaming, staring into space", "Fiddling with materials, doodling, or handling unrelated objects", "Beginning a task very slowly or on wrong assignment", "Pretending to work while doing something else (e.g. playing on a device)", "Asking off-topic questions to stall"],
                consequences: ["Teacher prompts or reminders to focus (teacher attention)", "Task may be simplified or re-taught", "Student may lose participation privileges or breaks", "If behavior continues, student may be removed from task (escape from demand)"]
            },
            "Property Destruction": {
                antecedents: ["Denied access to desired object or activity (frustration)", "Unstructured moments with access to items", "High emotional arousal (e.g. after reprimand)"],
                behaviors: ["Tearing or ripping paper, books, or clothing", "Bending, breaking, or smashing objects (toys, furniture, pencil)", "Drawing on or carving into walls, desks or personal property", "Kicking or punching walls or furniture", "Throwing objects forcefully to break them"],
                consequences: ["Student required to clean up or repair damage", "Loss of access to items (item taken away) or privileges", "Time-out or removal from class", "Teacher reprimand or referral"]
            }
        };

        // DOM elements
        const studentAgeInput = document.getElementById('studentAge');
        const studentGradeSelect = document.getElementById('studentGrade');
        const reinforcerPreferencesInput = document.getElementById('reinforcerPreferences');
        const behavioralSkillsSelect = document.getElementById('behavioralSkillsSelect');
        const socialSkillsSelect = document.getElementById('socialSkillsSelect');
        const pragmaticLanguageSkillsSelect = document.getElementById('pragmaticLanguageSkillsSelect');
        const anecdotalInput = document.getElementById('anecdotal');
        const referralInput = document.getElementById('referral');
        const generateBIPButton = document.getElementById('generateBIPButton');
        const generateBIPSpinner = document.getElementById('generateBIPSpinner');
        const bipOutputDiv = document.getElementById('bipOutput');
        const bipFunctionHypothesis = document.getElementById('bipFunctionHypothesis');
        const bipAntecedentStrategies = document.getElementById('bipAntecedentStrategies');
        const bipShortTermBehaviors = document.getElementById('bipShortTermBehaviors');
        const bipTeachingStrategies = document.getElementById('bipTeachingStrategies');
        const bipReinforcementShortTerm = document.getElementById('bipReinforcementShortTerm');
        const bipLongTermBehaviors = document.getElementById('bipLongTermBehaviors');
        const bipResponseStrategies = document.getElementById('bipResponseStrategies');
        const copyBIPButton = document.getElementById('copyBIPButton');
        const sessionStatusDisplay = document.getElementById('sessionStatusDisplay');
        const addReferralYes = document.getElementById('addReferralYes');
        const addReferralNo = document.getElementById('addReferralNo');
        const referralInfoContainer = document.getElementById('referralInfoContainer');


        addReferralYes.addEventListener('change', () => {
            referralInfoContainer.classList.remove('hidden');
        });
        addReferralNo.addEventListener('change', () => {
            referralInfoContainer.classList.add('hidden');
        });

        function populateSelectWithOptions(selectElement, optionsArray, defaultOptionText, keepOther = true) {
            const existingOtherOption = selectElement.querySelector('option[value="Other"]');
            selectElement.innerHTML = `<option value="">${defaultOptionText}</option>`; 

            optionsArray.forEach(optionText => {
                const option = document.createElement('option');
                option.value = optionText;
                option.textContent = optionText;
                selectElement.appendChild(option);
            });

            if (keepOther && existingOtherOption) {
                 selectElement.appendChild(existingOtherOption.cloneNode(true));
            } else if (keepOther && !existingOtherOption) { 
                const otherOption = document.createElement('option');
                otherOption.value = "Other";
                otherOption.textContent = "Other (Specify in Notes)";
                selectElement.appendChild(otherOption);
            }
        }

        function initializeBehaviorDropdowns() {
            const behaviorTypeKeys = Object.keys(bipData);
            for (let i = 0; i < 3; i++) {
                const behaviorTypeSelect = document.getElementById(`behaviorTypeSelect_${i}`);
                const antecedentSelect = document.getElementById(`antecedentSelect_${i}`);
                const behaviorSelect = document.getElementById(`behaviorSelect_${i}`);
                const consequenceSelect = document.getElementById(`consequenceSelect_${i}`);
                populateSelectWithOptions(behaviorTypeSelect, behaviorTypeKeys, "Select Behavior Type");
                behaviorTypeSelect.addEventListener('change', function() {
                    const selectedBehaviorType = this.value;
                    if (selectedBehaviorType && bipData[selectedBehaviorType]) {
                        populateSelectWithOptions(antecedentSelect, bipData[selectedBehaviorType].antecedents, "Select Antecedent");
                        populateSelectWithOptions(behaviorSelect, bipData[selectedBehaviorType].behaviors, "Select Specific Behavior");
                        populateSelectWithOptions(consequenceSelect, bipData[selectedBehaviorType].consequences, "Select Consequence");
                    } else {
                        populateSelectWithOptions(antecedentSelect, [], "Select Antecedent (after choosing type)");
                        populateSelectWithOptions(behaviorSelect, [], "Select Specific Behavior (after choosing type)");
                        populateSelectWithOptions(consequenceSelect, [], "Select Consequence (after choosing type)");
                    }
                });
                populateSelectWithOptions(antecedentSelect, [], "Select Antecedent (after choosing type)");
                populateSelectWithOptions(behaviorSelect, [], "Select Specific Behavior (after choosing type)");
                populateSelectWithOptions(consequenceSelect, [], "Select Consequence (after choosing type)");
            }
        }
        
        initializeBehaviorDropdowns();

        // --- UPDATED createPromptFromForm FUNCTION ---
        function createPromptFromForm() {
            const age = studentAgeInput.value || 'Not specified';
            const grade = studentGradeSelect.value || 'Not specified';
            const reinforcers = reinforcerPreferencesInput.value || 'Not specified';
            
            let anecdotal = anecdotalInput.value || 'No specific anecdotal notes provided.';
            if (anecdotalInput.value && !anecdotalInput.value.toLowerCase().includes("daily") && !anecdotalInput.value.toLowerCase().includes("weekly") && !anecdotalInput.value.toLowerCase().includes("often") && !anecdotalInput.value.toLowerCase().includes("frequently")) {
                anecdotal += " (Note: Assume these behavioral observations represent recurring patterns over time unless otherwise specified in the patterns below.)";
            }

            const referral = referralInput && !referralInfoContainer.classList.contains('hidden') ? referralInput.value : '';
            const behavioralLevel = behavioralSkillsSelect.value || 'Not specified';
            const socialLevel = socialSkillsSelect.value || 'Not specified';
            const pragmaticLevel = pragmaticLanguageSkillsSelect.value || 'Not specified';

            function getBehaviorBlock(index) {
                const type = document.getElementById(`behaviorTypeSelect_${index}`)?.value || '';
                const antecedent = document.getElementById(`antecedentSelect_${index}`)?.value || '';
                const behavior = document.getElementById(`behaviorSelect_${index}`)?.value || '';
                const consequence = document.getElementById(`consequenceSelect_${index}`)?.value || '';
                let result = '';
                if (type || antecedent || behavior || consequence) {
                    result = `Observed Recurring Behavior Pattern ${index + 1} (ABC Data):\n  Selected Behavior Type: ${type || 'Not specified'}\n  Selected Antecedent: ${antecedent || 'Not specified'}\n  Selected Specific Behavior: ${behavior || 'Not specified'}\n  Selected Typical Consequence: ${consequence || 'Not specified'}`;
                }
                return result;
            }
            const behaviors = [0,1,2].map(getBehaviorBlock).filter(Boolean).join('\n\n');

            const evidenceBasedStrategies = `
ADDITIONAL GUIDANCE FOR REPLACEMENT BEHAVIORS:
When developing the 'Short-term Replacement Behaviors', 'Teaching Strategies for Short-Term Replacement Behaviors', 'Reinforcement Strategies for Short-Term Replacement Behaviors', and 'Long-term Replacement Behaviors' sections, please consider the following evidence-based approaches, categorized by common behavioral functions. First, hypothesize the function based on the provided ABC data and student information. Then, select and adapt strategies relevant to that hypothesized function.

1. For ATTENTION-SEEKING BEHAVIORS:
   - Functional Communication Training (FCT): Teach appropriate ways to gain attention (e.g., raising hand, using a "help" card, polite verbal requests like "Excuse me" or "Am I doing good work?"). Immediately reinforce these appropriate requests with praise or desired interaction.
   - Scheduled Attention/Check-ins (Noncontingent Reinforcement - NCR): Provide brief, positive interactions on a regular schedule (e.g., every 10-15 minutes) regardless of the student's current behavior. This predictability can reduce anxiety about getting attention. Always use these check-ins to reinforce expected behaviors.
   - Differential Reinforcement of Alternative Behavior (DRA): Provide attention and rewards exclusively for the appropriate replacement behavior for seeking attention. Withhold attention/rewards when the problem attention-seeking behavior occurs.
   - Visual Supports & Social Stories: Use visual cues (e.g., picture of hand-raising) and social narratives to clearly illustrate expected methods for seeking attention and waiting for a turn.
   - Planned Ignoring & Redirecting: Consistently ignore minor, safe attention-seeking actions. When the student attempts the appropriate replacement behavior, immediately provide attention or praise. (Not for aggressive or self-injurious behaviors).

2. For ESCAPE/AVOIDANCE BEHAVIORS:
   - FCT for Breaks/Help: Teach the student to request breaks or assistance using cards, pictures, or specific phrases (e.g., "I need a break," "Help please," "I don't understand") when tasks are difficult. Reinforce these requests.
   - Choice-Making: Offer limited, appropriate choices related to tasks to increase the student's sense of control (e.g., "Worksheet with pencil or marker?", "Work at desk or on the rug?"). The core task requirement remains.
   - Task Modification & Support: Break down difficult tasks into smaller, manageable steps; simplify instructions; or shorten work sessions. Provide visual aids or one-on-one help. Consider high-probability request sequences.
   - Scheduled Breaks (NCR for Escape): Implement brief, routine breaks independent of the student's behavior (e.g., a short walk every 10 minutes of work).
   - Visual Timers & Priming: Use timers, countdowns, or visual schedules to show remaining task time. Provide advance warnings for transitions or changes in activity.

3. For ACCESS-TO-TANGIBLES BEHAVIORS:
   - FCT for Requests: Teach clear and appropriate ways to request desired items or activities (e.g., "Can I have X, please?", picture exchange). Immediately honor successful, appropriate requests.
   - Differential Reinforcement (DRA): Reinforce only appropriate requesting behaviors. Withhold the desired tangible item/activity when the student uses problem behaviors (e.g., grabbing, tantrums) to try to obtain it.
   - Scheduled Access & Token Systems: Plan regular, predictable opportunities for the student to access preferred items or activities. Use visual systems like "first/then" boards or token economies to link task completion with access to tangibles.
   - Sharing and Turn-Taking Skills: Explicitly teach, model, and practice skills for sharing and taking turns, using role-play, timers, and scripts. Reinforce cooperative behaviors.

4. For SENSORY-STIMULATION BEHAVIORS:
   - Sensory Breaks & Movement: Schedule regular opportunities for appropriate sensory or motor activities (e.g., jumping jacks, wall push-ups, short walks, stretch breaks, trampoline time) to provide needed input in a planned way.
   - Sensory Tools & Alternatives: Provide a selection of acceptable sensory items (e.g., stress balls, fidget toys, chewable jewelry) and teach the student when and how to use them as an alternative to inappropriate sensory-seeking behaviors. Praise appropriate use.
   - Environmental Modifications: Adapt the learning environment to reduce sensory overload (e.g., allow noise-canceling headphones, dim lights, provide a quieter workspace). Prepare the student for known sensory events using schedules or priming.
   - Calming & Self-Regulation Techniques: Teach simple coping strategies like deep breathing, counting, or using a designated "calm-down corner." Practice these techniques when the student is calm.
Remember that all strategies should be consistently implemented across settings and by all relevant staff.
`;

            return `
Act as an expert Board Certified Behavior Analyst (BCBA) in a school setting. Your primary task is to develop a comprehensive and actionable Behavior Intervention Plan (BIP) based on the student information provided below.

It is crucial to understand that the observed behaviors described are **recurring patterns that have been happening over time**, not isolated incidents. Therefore, the entire BIP, including all strategies, must reflect this understanding of chronicity and learned history.

Student Information:
Student Age: ${age}
Grade: ${grade}
Preferred Reinforcers: ${reinforcers}
Anecdotal Notes (including context of recurrence, frequency, intensity, duration if available): ${anecdotal}
${referral ? "Referral Information: " + referral : ""}
Current Behavioral Skills Level: ${behavioralLevel}
Current Social Skills Level: ${socialLevel}
Current Pragmatic Language Skills Level: ${pragmaticLevel}

Observed Recurring Behavior Patterns (ABC Data - based on dropdown selections):
${behaviors || 'No specific recurring behavior patterns selected. If none are detailed, use the anecdotal notes to infer patterns.'}

${evidenceBasedStrategies}

Please generate the Behavior Intervention Plan. Format your response using these section headings (exactly as written). Ensure ALL sections are thoroughly addressed with specific, actionable, and research-based strategies appropriate for a school environment, drawing from the evidence-based strategies provided above where relevant to the hypothesized function. **You should act as if you have all necessary information to complete every section of the plan comprehensively and should attempt to provide recommendations for all listed sections. Do not state that more information is needed for any section; instead, provide the best possible strategies based on the information at hand.**

**Critically, the 'Response Strategies for Problem Behavior' section must be detailed and robust.** This section should clearly outline:
1.  Immediate actions to take when the problem behavior pattern occurs to ensure the safety of the student and others.
2.  De-escalation techniques suitable for the described behavior patterns and student characteristics.
3.  Clear, brief, and consistent verbal and non-verbal responses from staff.
4.  Procedures for follow-up after an incident, including re-teaching, and how to return the student to the learning environment.
5.  Avoid strategies that could inadvertently reinforce the problem behavior based on its hypothesized function.

Required BIP Sections:
Function Hypothesis Statement:
Antecedent Strategies:
Short-term Replacement Behaviors:
Teaching Strategies for Short-Term Replacement Behaviors:
Reinforcement Strategies for Short-Term Replacement Behaviors:
Long-term Replacement Behaviors:
Response Strategies for Problem Behavior:
            `.trim();
        }

        // --- REVISED parsePlanSections FUNCTION ---
        function parsePlanSections(planText) {
            // ... (rest of the function remains the same as your last version)
            console.log("[FRONTEND] parsePlanSections received planText (length):", planText.length);
            const sectionKeys = [ 
                "Function Hypothesis Statement", "Antecedent Strategies", "Short-term Replacement Behaviors",
                "Teaching Strategies for Short-Term Replacement Behaviors", "Reinforcement Strategies for Short-Term Replacement Behaviors",
                "Long-term Replacement Behaviors", "Response Strategies for Problem Behavior"
            ];
            const sections = {};
            sectionKeys.forEach(key => sections[key] = ""); 

            const lines = planText.split('\n');
            let currentSectionKey = null;
            let contentForCurrentSection = [];

            for (const line of lines) {
                let matchedNewSection = false;
                for (const key of sectionKeys) {
                    const trimmedLine = line.trim();
                    const pattern = new RegExp(`^(?:\\*\\*)?${key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(?:\\*\\*)?:`, "i");
                    if (pattern.test(trimmedLine)) {
                        if (currentSectionKey && contentForCurrentSection.length > 0) {
                            sections[currentSectionKey] = contentForCurrentSection.join('\n').trim();
                        }
                        currentSectionKey = key;
                        contentForCurrentSection = []; 
                        const contentOnHeadingLine = trimmedLine.replace(pattern, "").trim();
                        if (contentOnHeadingLine) contentForCurrentSection.push(contentOnHeadingLine);
                        matchedNewSection = true;
                        break; 
                    }
                }
                if (!matchedNewSection && currentSectionKey) {
                    if (line.trim() !== "" || contentForCurrentSection.length > 0) contentForCurrentSection.push(line); 
                }
            }
            if (currentSectionKey && contentForCurrentSection.length > 0) {
                sections[currentSectionKey] = contentForCurrentSection.join('\n').trim();
            }
            for (let key in sections) sections[key] = sections[key].trim();
            console.log("[FRONTEND] parsePlanSections generated sections:", JSON.parse(JSON.stringify(sections)));
            return sections;
        }

        function showPlanSections(sections) {
            // ... (rest of the function remains the same as your last version)
            console.log("[FRONTEND] showPlanSections received sections:", JSON.parse(JSON.stringify(sections)));
            const fallbackMsg = "The AI attempted to generate this section but may require more specific input for optimal results. Review and refine as needed."; // Changed fallback message
            bipFunctionHypothesis.textContent = sections["Function Hypothesis Statement"] || fallbackMsg;
            bipAntecedentStrategies.textContent = sections["Antecedent Strategies"] || fallbackMsg;
            bipShortTermBehaviors.textContent = sections["Short-term Replacement Behaviors"] || fallbackMsg;
            bipTeachingStrategies.textContent = sections["Teaching Strategies for Short-Term Replacement Behaviors"] || fallbackMsg;
            bipReinforcementShortTerm.textContent = sections["Reinforcement Strategies for Short-Term Replacement Behaviors"] || fallbackMsg;
            bipLongTermBehaviors.textContent = sections["Long-term Replacement Behaviors"] || fallbackMsg;
            bipResponseStrategies.textContent = sections["Response Strategies for Problem Behavior"] || fallbackMsg; 
            bipOutputDiv.classList.remove('hidden');
            console.log("[FRONTEND] bipOutputDiv should now be visible.");
        }

        function showErrorOutput(msg) {
            // ... (rest of the function remains the same as your last version)
            console.log("[FRONTEND] showErrorOutput called with msg:", msg);
            bipFunctionHypothesis.textContent = msg;
            bipAntecedentStrategies.textContent = ""; 
            bipShortTermBehaviors.textContent = "";
            bipTeachingStrategies.textContent = "";
            bipReinforcementShortTerm.textContent = "";
            bipLongTermBehaviors.textContent = "";
            bipResponseStrategies.textContent = ""; 
            bipOutputDiv.classList.remove('hidden');
        }

        function hidePlanOutput() {
            // ... (rest of the function remains the same as your last version)
            bipFunctionHypothesis.textContent = "";
            bipAntecedentStrategies.textContent = "";
            bipShortTermBehaviors.textContent = "";
            bipTeachingStrategies.textContent = "";
            bipReinforcementShortTerm.textContent = "";
            bipLongTermBehaviors.textContent = "";
            bipResponseStrategies.textContent = ""; 
            bipOutputDiv.classList.add('hidden');
        }

        async function generatePlanWithGemini() {
            // ... (rest of the function remains the same as your last version, including enhanced error handling)
            console.log("[FRONTEND] generatePlanWithGemini called");
            generateBIPSpinner.classList.remove('hidden');
            generateBIPButton.disabled = true;
            sessionStatusDisplay.textContent = "Generating...";
            hidePlanOutput();
            const userGeneratedPrompt = createPromptFromForm();
            console.log("[FRONTEND] Generated prompt for backend (first 500 chars):", userGeneratedPrompt.substring(0,500) + "..."); 
            const backendApiUrl = '/api/ask'; 
            const requestBody = { prompt: userGeneratedPrompt };
            try {
                const response = await fetch(backendApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                console.log("[FRONTEND] Received response from backend. Status:", response.status, "Ok:", response.ok); 
                const data = await response.json();
                console.log("[FRONTEND] Parsed data from backend response (structure check):", data ? "Data received" : "No data received");
                if (!response.ok) {
                    let errorMsg = data.error || `Request failed with status ${response.status}`;
                    if (data.details) errorMsg += `\nDetails: ${typeof data.details === 'object' ? JSON.stringify(data.details) : data.details}`;
                    showErrorOutput("Failed to generate a plan (server error).\n" + errorMsg);
                    console.error("[FRONTEND] Backend Error (response not ok):", data);
                } else if (data.error) { 
                    let errorMsg = data.error.message || JSON.stringify(data.error, null, 2);
                    if (data.error.details) errorMsg += `\nDetails: ${JSON.stringify(data.error.details, null, 2)}`;
                    showErrorOutput("Failed to generate a plan (API error).\n" + errorMsg);
                    console.error("[FRONTEND] Gemini API Error (via backend, data.error is present):", data.error);
                } else if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0 && data.candidates[0].content.parts[0].text) {
                    console.log("[FRONTEND] Valid candidates found in data. Processing plan.");
                    const planText = data.candidates[0].content.parts[0].text;
                    const sections = parsePlanSections(planText);
                    showPlanSections(sections);
                } else {
                    let specificError = "Received an unexpected response from the server or no plan was generated.";
                    if (data.candidates && data.candidates.length > 0 && data.candidates[0].finishReason) {
                         specificError = `The response generation finished with reason: ${data.candidates[0].finishReason}. `;
                         if (data.candidates[0].finishReason === "SAFETY") {
                           specificError += "This often means the content was blocked by safety filters. Review input and safety settings. ";
                           console.warn("[FRONTEND] Response blocked due to SAFETY finishReason", data.candidates[0].safetyRatings);
                         } else if (data.candidates[0].finishReason === "MAX_TOKENS") {
                            specificError += "The maximum number of tokens for the response was reached. The plan may be incomplete. ";
                         } else if (data.candidates[0].finishReason === "RECITATION") {
                            specificError += "The response was blocked due to detected recitation from a source. ";
                         }
                    } else if (data.promptFeedback && data.promptFeedback.blockReason) {
                         specificError = `The prompt was blocked by the API. Reason: ${data.promptFeedback.blockReason}.`;
                         if (data.promptFeedback.safetyRatings) specificError += ` Details: ${JSON.stringify(data.promptFeedback.safetyRatings)}`;
                         console.warn("[FRONTEND] Prompt blocked by API", data.promptFeedback);
                    } else {
                        console.log("[FRONTEND] Response OK, but no valid candidates or text found in data, or unexpected structure."); 
                        console.error("[FRONTEND] Unexpected successful response structure:", data);
                    }
                    showErrorOutput(specificError);
                }
            } catch (err) {
                console.error("[FRONTEND] Error in fetch try-catch block (e.g., network error, or response.json() failed):", err); 
                showErrorOutput("An error occurred while communicating with the server: " + err.message);
            } finally {
                generateBIPSpinner.classList.add('hidden');
                generateBIPButton.disabled = false;
                sessionStatusDisplay.textContent = "Active";
                console.log("[FRONTEND] generatePlanWithGemini finished.");
            }
        }

        generateBIPButton.addEventListener('click', (e) => {
            e.preventDefault();
            generatePlanWithGemini();
        });

        copyBIPButton.addEventListener('click', () => {
            // ... (rest of the function remains the same as your last version)
            let textToCopy = 
`Function Hypothesis Statement:
${bipFunctionHypothesis.textContent}
Antecedent Strategies:
${bipAntecedentStrategies.textContent}
Short-term Replacement Behaviors:
${bipShortTermBehaviors.textContent}
Teaching Strategies for Short-Term Replacement Behaviors:
${bipTeachingStrategies.textContent}
Reinforcement Strategies for Short-Term Replacement Behaviors:
${bipReinforcementShortTerm.textContent}
Long-term Replacement Behaviors:
${bipLongTermBehaviors.textContent}
Response Strategies for Problem Behavior:
${bipResponseStrategies.textContent}
`;
            navigator.clipboard.writeText(textToCopy);
            const originalButtonText = copyBIPButton.innerHTML; 
            copyBIPButton.innerHTML = '<i class="fas fa-check mr-2"></i> Copied!';
            setTimeout(() => { copyBIPButton.innerHTML = originalButtonText; }, 2000);
        });

        document.getElementById('newPlanButton').addEventListener('click', () => {
            // ... (rest of the function remains the same as your last version)
            studentAgeInput.value = '';
            studentGradeSelect.value = '';
            reinforcerPreferencesInput.value = '';
            anecdotalInput.value = '';
            referralInput.value = '';
            behavioralSkillsSelect.value = '';
            socialSkillsSelect.value = '';
            pragmaticLanguageSkillsSelect.value = '';
            for (let i = 0; i < 3; i++) {
                const behaviorTypeSelect = document.getElementById(`behaviorTypeSelect_${i}`);
                behaviorTypeSelect.value = '';
                behaviorTypeSelect.dispatchEvent(new Event('change'));

                document.getElementById(`antecedentSelect_${i}`).innerHTML = '<option value="">Select Antecedent (after choosing type)</option><option value="Other">Other (Specify in Notes)</option>';
                document.getElementById(`behaviorSelect_${i}`).innerHTML = '<option value="">Select Specific Behavior (after choosing type)</option><option value="Other">Other (Specify in Notes)</option>';
                document.getElementById(`consequenceSelect_${i}`).innerHTML = '<option value="">Select Consequence (after choosing type)</option><option value="Other">Other (Specify in Notes)</option>';
            }
            addReferralNo.checked = true;
            referralInfoContainer.classList.add('hidden');
            hidePlanOutput();
            sessionStatusDisplay.textContent = "Active";
            console.log("[FRONTEND] New plan started, fields cleared.");
        });
    </script>
</body>
</html>
